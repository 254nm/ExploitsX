/*
 * .. _____________________ ..
 *  -- // WARNING \\ --
 *  -- THIS WORK IS UNDER EXCLUSIVE COPRIGHT FOR BAITCORP LABS. DISTRIBUTION, MODIFICATION, SELLING, OR SHARING WITHOUT EXPLICIT PERMISSION FROM BAITCORP LABS IS STRICTLY PROHIBITED.
 *  -- THIS PROGRAM IS LICENSED FOR MODIFICATION TO AND ONLY TO: "BAITCORP LABS" [FR], "CCHOST PARIS" [FR].
 *  --
 *  -- ExploitsX Sebastian Giheta 2019-2020
 * .. _____________________ ..
 *
 * .. _____________________ ..
 *  ___________              .__         .__  __         ____  ___              _________ .__            __   _________
 *  \_   _____/__  _________ |  |   ____ |__|/  |_  _____\   \/  /     .__      \_   ___ \|  |__ _____ _/  |_ \_   ___ \  ____
 *   |    __)_\  \/  /\____ \|  |  /  _ \|  \   __\/  ___/\     /    __|  |___  /    \  \/|  |  \\__  \\   __\/    \  \/ /  _ \
 *   |        \>    < |  |_> >  |_(  <_> )  ||  |  \___ \ /     \   /__    __/  \     \___|   Y  \/ __ \|  |  \     \___(  <_> )
 *  /_______  /__/\_ \|   __/|____/\____/|__||__| /____  >___/\  \     |__|      \______  /___|  (____  /__|   \______  /\____/
 *          \/      \/|__|                             \/      \_/                      \/     \/     \/              \/
 *
 *  ExploitsX by Sebastian Giheta, owner of 8b8t.xyz
 * .. _____________________ ..
 */

package me.bait.exploitfixer.chatco;

import com.google.common.base.Strings;
import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableBiMap;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Vector;

public class JSONMessage {
	private static final BiMap<ChatColor, String> stylesToNames;

	static {
		ImmutableBiMap.Builder<ChatColor, String> builder = ImmutableBiMap.builder();
		byte b;
		int i;
		ChatColor[] arrayOfChatColor;
		for (i = (arrayOfChatColor = ChatColor.values()).length, b = 0; b < i; ) {
			ChatColor style = arrayOfChatColor[b];
			if (style.isFormat()) {
				String styleName;
				switch (style) {
					case MAGIC:
						styleName = "obfuscated";
						break;
					case UNDERLINE:
						styleName = "underlined";
						break;
					default:
						styleName = style.name().toLowerCase();
						break;
				}
				builder.put(style, styleName);
			}
			b++;
		}

		stylesToNames = builder.build();
	}

	private final List<MessagePart> parts = new ArrayList<>();
	private int centeringStartIndex = -1;

	private JSONMessage(String text) {
		this.parts.add(new MessagePart(text));
	}

	public static void actionbar(String message, Player... players) {
		ReflectionHelper.sendPacket(
				ReflectionHelper.createActionbarPacket(ChatColor.translateAlternateColorCodes('&', message)), players);
	}

	public static JSONMessage create() {
		return create("");
	}

	public static JSONMessage create(String text) {
		return new JSONMessage(text);
	}

	public JSONMessage achievement(String id) {
		last().setOnHover(HoverEvent.showAchievement(id));
		return this;
	}

	public void actionbar(Player... players) {
		actionbar(toLegacy(), players);
	}

	public JSONMessage bar() {
		return bar(53);
	}

	public JSONMessage bar(int length) {
		return then(Strings.repeat("-", length)).color(ChatColor.DARK_GRAY).style(ChatColor.STRIKETHROUGH);
	}

	public JSONMessage beginCenter() {
		this.centeringStartIndex = this.parts.size();
		return this;
	}

	public JSONMessage changePage(int page) {
		last().setOnClick(ClickEvent.changePage(page));
		return this;
	}

	public JSONMessage color(ChatColor color) {
		last().setColor(color);
		return this;
	}

	public JSONMessage endCenter() {
		int current = this.centeringStartIndex;
		while (current < this.parts.size()) {
			Vector<MessagePart> currentLine = new Vector<>();
			int totalLineLength = 0;
			for (; ; current++) {
				MessagePart part = (current < this.parts.size()) ? this.parts.get(current) : null;
				String raw = (part == null) ? null : ChatColor.stripColor(part.toLegacy());
				if (current >= this.parts.size() || totalLineLength + raw.length() >= 53) {
					int padding = Math.max(0, (53 - totalLineLength) / 2);
					currentLine.firstElement()
							.setText(Strings.repeat(" ", padding) + currentLine.firstElement().getText());
					currentLine.lastElement().setText(currentLine.lastElement().getText() + "\n");
					currentLine.clear();
					break;
				}
				totalLineLength += raw.length();
				currentLine.add(part);
			}
		}
		MessagePart last = this.parts.get(this.parts.size() - 1);
		last.setText(last.getText().substring(0, last.getText().length() - 1));
		this.centeringStartIndex = -1;
		return this;
	}

	public MessagePart last() {
		if (this.parts.size() <= 0)
			throw new ArrayIndexOutOfBoundsException("No MessageParts exist!");
		return this.parts.get(this.parts.size() - 1);
	}

	public JSONMessage newline() {
		return then("\n");
	}

	public JSONMessage openURL(String url) {
		last().setOnClick(ClickEvent.openURL(url));
		return this;
	}

	public JSONMessage runCommand(String command) {
		last().setOnClick(ClickEvent.runCommand(command));
		return this;
	}

	public void send(Player... players) {
		ReflectionHelper.sendPacket(ReflectionHelper.createTextPacket(toString()), players);
	}

	public JSONMessage style(ChatColor style) {
		last().addStyle(style);
		return this;
	}

	public void subtitle(Player... players) {
		ReflectionHelper.sendPacket(ReflectionHelper.createSubtitlePacket(toString()), players);
	}

	public JSONMessage suggestCommand(String command) {
		last().setOnClick(ClickEvent.suggestCommand(command));
		return this;
	}

	public JSONMessage then(MessagePart nextPart) {
		this.parts.add(nextPart);
		return this;
	}

	public JSONMessage then(String text) {
		return then(new MessagePart(text));
	}

	public void title(int fadeIn, int stay, int fadeOut, Player... players) {
		ReflectionHelper.sendPacket(ReflectionHelper.createTitleTimesPacket(fadeIn, stay, fadeOut), players);
		ReflectionHelper.sendPacket(ReflectionHelper.createTitlePacket(toString()), players);
	}

	public JsonObject toJSON() {
		JsonObject obj = new JsonObject();
		obj.addProperty("text", "");
		JsonArray array = new JsonArray();
		Objects.requireNonNull(array);
		this.parts.stream().map(MessagePart::toJSON).forEach(array::add);
		obj.add("extra", array);
		return obj;
	}

	public String toLegacy() {
		StringBuilder output = new StringBuilder();
		Objects.requireNonNull(output);
		this.parts.stream().map(MessagePart::toLegacy).forEach(output::append);
		return output.toString();
	}

	public JSONMessage tooltip(JSONMessage message) {
		last().setOnHover(HoverEvent.showText(message));
		return this;
	}

	public JSONMessage tooltip(String text) {
		last().setOnHover(HoverEvent.showText(text));
		return this;
	}

	public String toString() {
		return toJSON().toString();
	}

	public static class ClickEvent {
		public static JSONMessage.MessageEvent changePage(int page) {
			return new JSONMessage.MessageEvent("change_page", page);
		}

		public static JSONMessage.MessageEvent openURL(String url) {
			return new JSONMessage.MessageEvent("open_url", url);
		}

		public static JSONMessage.MessageEvent runCommand(String command) {
			return new JSONMessage.MessageEvent("run_command", command);
		}

		public static JSONMessage.MessageEvent suggestCommand(String command) {
			return new JSONMessage.MessageEvent("suggest_command", command);
		}
	}

	public static class HoverEvent {
		public static JSONMessage.MessageEvent showAchievement(String id) {
			return new JSONMessage.MessageEvent("show_achievement", id);
		}

		public static JSONMessage.MessageEvent showText(JSONMessage message) {
			JsonArray arr = new JsonArray();
			arr.add(new JsonPrimitive(""));
			arr.add(message.toJSON());
			return new JSONMessage.MessageEvent("show_text", arr);
		}

		public static JSONMessage.MessageEvent showText(String text) {
			return new JSONMessage.MessageEvent("show_text", text);
		}
	}

	public static class MessageEvent {
		private String action;
		private Object value;

		public MessageEvent(String action, Object value) {
			this.action = action;
			this.value = value;
		}

		public String getAction() {
			return this.action;
		}

		public void setAction(String action) {
			this.action = action;
		}

		public Object getValue() {
			return this.value;
		}

		public void setValue(Object value) {
			this.value = value;
		}

		public JsonObject toJSON() {
			JsonObject obj = new JsonObject();
			obj.addProperty("action", this.action);
			if (this.value instanceof JsonElement) {
				obj.add("value", (JsonElement) this.value);
			} else {
				obj.addProperty("value", this.value.toString());
			}
			return obj;
		}
	}

	private static class ReflectionHelper {
		private static final String version;
		private static Constructor<?> chatComponentText;
		private static Class<?> packetPlayOutChat;
		private static Class<?> packetPlayOutTitle;
		private static Class<?> iChatBaseComponent;
		private static Class<?> titleAction;
		private static Field connection;
		private static MethodHandle GET_HANDLE;
		private static MethodHandle SEND_PACKET;
		private static MethodHandle STRING_TO_CHAT;
		private static Object enumActionTitle;
		private static Object enumActionSubtitle;
		private static Object enumChatMessage;
		private static Object enumActionbarMessage;
		private static boolean SETUP;
		private static int MAJOR_VER = -1;

		static {
			String[] split = Bukkit.getServer().getClass().getPackage().getName().split("\\.");
			version = split[split.length - 1];
			try {
				Method stringToChat;
				SETUP = true;
				MAJOR_VER = getVersion();
				Class<?> craftPlayer = getClass("{obc}.entity.CraftPlayer");
				Method getHandle = craftPlayer.getMethod("getHandle");
				connection = getHandle.getReturnType().getField("playerConnection");
				Method sendPacket = connection.getType().getMethod("sendPacket", getClass("{nms}.Packet"));
				chatComponentText = getClass("{nms}.ChatComponentText").getConstructor(String.class);
				iChatBaseComponent = getClass("{nms}.IChatBaseComponent");
				if (MAJOR_VER < 8) {
					stringToChat = getClass("{nms}.ChatSerializer").getMethod("a", String.class);
				} else {
					stringToChat = getClass("{nms}.IChatBaseComponent$ChatSerializer").getMethod("a", String.class);
				}
				GET_HANDLE = MethodHandles.lookup().unreflect(getHandle);
				SEND_PACKET = MethodHandles.lookup().unreflect(sendPacket);
				STRING_TO_CHAT = MethodHandles.lookup().unreflect(stringToChat);
				packetPlayOutChat = getClass("{nms}.PacketPlayOutChat");
				packetPlayOutTitle = getClass("{nms}.PacketPlayOutTitle");
				titleAction = getClass("{nms}.PacketPlayOutTitle$EnumTitleAction");
				enumActionTitle = titleAction.getField("TITLE").get(null);
				enumActionSubtitle = titleAction.getField("SUBTITLE").get(null);
				if (MAJOR_VER >= 12) {
					Method getChatMessageType = getClass("{nms}.ChatMessageType").getMethod("a", byte.class);
					enumChatMessage = getChatMessageType.invoke(null, (byte) 1);
					enumActionbarMessage = getChatMessageType.invoke(null, (byte) 2);
				}
			} catch (Exception e) {
				e.printStackTrace();
				SETUP = false;
			}
		}

		static Object componentText(String message) {
			if (!SETUP)
				throw new IllegalStateException("ReflectionHelper is not set up!");
			try {
				return chatComponentText.newInstance(message);
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
		}

		static Object createActionbarPacket(String message) {
			if (!SETUP)
				throw new IllegalStateException("ReflectionHelper is not set up!");
			Object packet = createTextPacket(message);
			setType(packet, (byte) 2);
			return packet;
		}

		static Object createSubtitlePacket(String message) {
			if (!SETUP)
				throw new IllegalStateException("ReflectionHelper is not set up!");
			try {
				return packetPlayOutTitle.getConstructor(new Class[]{titleAction, iChatBaseComponent
				}).newInstance(enumActionSubtitle, fromJson(message));
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
		}

		static Object createTextPacket(String message) {
			if (!SETUP)
				throw new IllegalStateException("ReflectionHelper is not set up!");
			try {
				Object packet = packetPlayOutChat.newInstance();
				set("a", packet, fromJson(message));
				setType(packet, (byte) 1);
				return packet;
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
		}

		static Object createTitlePacket(String message) {
			if (!SETUP)
				throw new IllegalStateException("ReflectionHelper is not set up!");
			try {
				return packetPlayOutTitle.getConstructor(new Class[]{titleAction, iChatBaseComponent
				}).newInstance(enumActionTitle, fromJson(message));
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
		}

		static Object createTitleTimesPacket(int fadeIn, int stay, int fadeOut) {
			if (!SETUP)
				throw new IllegalStateException("ReflectionHelper is not set up!");
			try {
				return packetPlayOutTitle.getConstructor(new Class[]{Integer.class, Integer.class, Integer.class}).newInstance(
						fadeIn, stay, fadeOut);
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
		}

		static Object fromJson(String json) {
			if (!SETUP)
				throw new IllegalStateException("ReflectionHelper is not set up!");
			if (!json.trim().startsWith("{"))
				return componentText(json);
			try {
				return STRING_TO_CHAT.invoke(json);
			} catch (Throwable e) {
				e.printStackTrace();
				return null;
			}
		}

		static Class<?> getClass(String path) throws ClassNotFoundException {
			if (!SETUP)
				throw new IllegalStateException("ReflectionHelper is not set up!");
			return Class.forName(path.replace("{nms}", "net.minecraft.server." + version).replace("{obc}",
					"org.bukkit.craftbukkit." + version));
		}

		static int getVersion() {
			if (!SETUP)
				throw new IllegalStateException("ReflectionHelper is not set up!");
			try {
				return Integer.parseInt(version.split("_")[1]);
			} catch (NumberFormatException e) {
				e.printStackTrace();
				return 10;
			}
		}

		static void sendPacket(Object packet, Player... players) {
			if (!SETUP)
				throw new IllegalStateException("ReflectionHelper is not set up!");
			if (packet == null)
				return;
			byte b;
			int i;
			Player[] arrayOfPlayer;
			for (i = (arrayOfPlayer = players).length, b = 0; b < i; ) {
				Player player = arrayOfPlayer[b];
				try {
					SEND_PACKET.bindTo(connection.get(GET_HANDLE.bindTo(player).invoke())).invoke(packet);
				} catch (Throwable e) {
					System.err.println("Failed to send packet");
					e.printStackTrace();
				}
				b++;
			}

		}

		static void set(String field, Object obj, Object value) {
			try {
				Field f = obj.getClass().getDeclaredField(field);
				f.setAccessible(true);
				f.set(obj, value);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		private static void setType(Object object, byte type) {
			if (MAJOR_VER < 12) {
				set("b", object, type);
				return;
			}
			switch (type) {
				case 1:
					set("b", object, enumChatMessage);
					return;
				case 2:
					set("b", object, enumActionbarMessage);
					return;
			}
			throw new IllegalArgumentException("type must be 1 or 2");
		}
	}

	public static class MessagePart {
		private final List<ChatColor> styles = new ArrayList<>();
		private JSONMessage.MessageEvent onClick;
		private JSONMessage.MessageEvent onHover;
		private ChatColor color;
		private String text;

		public MessagePart(String text) {
			this.text = (text == null) ? "null" : text;
		}

		public void addStyle(ChatColor style) {
			if (style == null)
				throw new IllegalArgumentException("Style cannot be null!");
			if (!style.isFormat())
				throw new IllegalArgumentException(this.color.name() + " is not a style!");
			this.styles.add(style);
		}

		public ChatColor getColor() {
			return this.color;
		}

		public void setColor(ChatColor color) {
			if (!color.isColor())
				throw new IllegalArgumentException(color.name() + " is not a color!");
			this.color = color;
		}

		public JSONMessage.MessageEvent getOnClick() {
			return this.onClick;
		}

		public void setOnClick(JSONMessage.MessageEvent onClick) {
			this.onClick = onClick;
		}

		public JSONMessage.MessageEvent getOnHover() {
			return this.onHover;
		}

		public void setOnHover(JSONMessage.MessageEvent onHover) {
			this.onHover = onHover;
		}

		public List<ChatColor> getStyles() {
			return this.styles;
		}

		public String getText() {
			return this.text;
		}

		public void setText(String text) {
			this.text = text;
		}

		public JsonObject toJSON() {
			Objects.requireNonNull(this.text);
			JsonObject obj = new JsonObject();
			obj.addProperty("text", this.text);
			if (this.color != null)
				obj.addProperty("color", this.color.name().toLowerCase());
			for (ChatColor style : this.styles)
				obj.addProperty(JSONMessage.stylesToNames.get(style), true);
			if (this.onClick != null)
				obj.add("clickEvent", this.onClick.toJSON());
			if (this.onHover != null)
				obj.add("hoverEvent", this.onHover.toJSON());
			return obj;
		}

		public String toLegacy() {
			StringBuilder output = new StringBuilder();
			if (this.color != null)
				output.append(this.color.toString());
			Objects.requireNonNull(output);
			this.styles.stream().map(ChatColor::toString).forEach(output::append);
			return output.append(this.text).toString();
		}
	}
}