/*
 * .. _____________________ ..
 *  -- // WARNING \\ --
 *  -- THIS WORK IS UNDER EXCLUSIVE COPRIGHT FOR BAITCORP LABS. DISTRIBUTION, MODIFICATION, SELLING, OR SHARING WITHOUT EXPLICIT PERMISSION FROM BAITCORP LABS IS STRICTLY PROHIBITED.
 *  -- THIS PROGRAM IS LICENSED FOR MODIFICATION TO AND ONLY TO: "BAITCORP LABS" [FR], "CCHOST PARIS" [FR].
 *  --
 *  -- ExploitsX Sebastian Giheta 2019-2020
 * .. _____________________ ..
 *
 * .. _____________________ ..
 *  ___________              .__         .__  __         ____  ___              _________ .__            __   _________
 *  \_   _____/__  _________ |  |   ____ |__|/  |_  _____\   \/  /     .__      \_   ___ \|  |__ _____ _/  |_ \_   ___ \  ____
 *   |    __)_\  \/  /\____ \|  |  /  _ \|  \   __\/  ___/\     /    __|  |___  /    \  \/|  |  \\__  \\   __\/    \  \/ /  _ \
 *   |        \>    < |  |_> >  |_(  <_> )  ||  |  \___ \ /     \   /__    __/  \     \___|   Y  \/ __ \|  |  \     \___(  <_> )
 *  /_______  /__/\_ \|   __/|____/\____/|__||__| /____  >___/\  \     |__|      \______  /___|  (____  /__|   \______  /\____/
 *          \/      \/|__|                             \/      \_/                      \/     \/     \/              \/
 *
 *  ExploitsX by Sebastian Giheta, owner of 8b8t.xyz
 * .. _____________________ ..
 */

package me.bait.exploitfixer.gameplay;

import me.bait.exploitfixer.exploitfixer;
import me.bait.exploitfixer.util.API;
import me.bait.exploitfixer.util.IPCrypt;
import me.bait.exploitfixer.util.TPS;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.configuration.InvalidConfigurationException;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.PlayerDeathEvent;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerQuitEvent;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;


public class RegisterStats implements CommandExecutor, Listener {
	public static HashMap<Player, Long> kill = new HashMap<>();
	public static HashMap<Player, Long> death = new HashMap<>();
	public static HashMap<Player, Long> time = new HashMap<>();
	public static HashMap<Player, Long> places = new HashMap<>();
	public static HashMap<Player, Long> breaks = new HashMap<>();
	public static HashMap<Player, Long> messages = new HashMap<>();
	public static HashMap<Player, Long> travel = new HashMap<>();

	public static void count() {
		double TPS1 = TPS.getTPS();
		for (Player p : Bukkit.getOnlinePlayers()) {
			if (time.containsKey(p)) {
				Long out = time.get(p);
				double timed = out.doubleValue();
				double calc = 100.0D / TPS1;
				timed = timed + calc;
				long v1 = Math.round(timed);
				time.put(p, v1);
			}
		}
	}

	public static void onChat(Player p) {
		if (messages.containsKey(p)) {
			Long message = messages.get(p);
			message = message + 1L;
			messages.put(p, message);
		}
	}

	public static void onDisable() {
		(new Thread(() -> {
			if (exploitfixer.getPlugin().getConfig().getBoolean("announcereloads")) {
				exploitfixer.getPlugin().getServer().broadcastMessage(ChatColor.DARK_RED + "ExploitsX " + ChatColor.AQUA + "v" + exploitfixer.getPlugin().getDescription().getVersion() + ChatColor.DARK_RED + " is reloading, (possible update) there might be a small lag spike...");
			}
			for (Player p : Bukkit.getOnlinePlayers()) {
				if (!RegisterStats.death.containsKey(p)) {
					RegisterStats.death.put(p, 0L);
				}
				if (!RegisterStats.kill.containsKey(p)) {
					RegisterStats.kill.put(p, 0L);
				}
				if (!RegisterStats.time.containsKey(p)) {
					RegisterStats.time.put(p, 0L);
				}
				if (!RegisterStats.places.containsKey(p)) {
					RegisterStats.places.put(p, 0L);
				}
				if (!RegisterStats.breaks.containsKey(p)) {
					RegisterStats.breaks.put(p, 0L);
				}
				if (!RegisterStats.messages.containsKey(p)) {
					RegisterStats.messages.put(p, 0L);
				}
				if (!RegisterStats.travel.containsKey(p)) {
					RegisterStats.travel.put(p, 0L);
				}
				String uuid = p.getUniqueId().toString();
				String firstThreeChars = uuid.substring(0, 3);
				File f = new File("plugins/ExploitsX/data/" + uuid + ".yml");
				YamlConfiguration yaml = YamlConfiguration.loadConfiguration(f);
				yaml = RegisterStats.setData(p, yaml);
				try {
					File dir = new File("plugins/ExploitsX/data/" + firstThreeChars);
					if (!dir.exists())
						dir.mkdirs();
					File file = new File("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml");
					if (file.exists()) {
						if (file.delete()) {
							if (exploitfixer.getPlugin().getConfig().getBoolean("debug")) {
								API.println("File: " + uuid + ".yml deleted successfully");
							}
						} else {
							API.println("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml could not be deleted! This might cause a player data problem....");
						}
					}
					yaml.save("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml");
				} catch (IOException e) {
					e.printStackTrace();
				}
				RegisterStats.removePlayer(p);
			}
		})).start();
	}

	public static void onEnable() {
		Bukkit.getScheduler().scheduleSyncRepeatingTask(exploitfixer.getPlugin(), RegisterStats::count, 0L, 100L);
		(new Thread(() -> {
			if (exploitfixer.getPlugin().getConfig().getBoolean("announcereloads")) {
				exploitfixer.getPlugin().getServer()
						.broadcastMessage(ChatColor.DARK_RED + "ExploitsX " + ChatColor.AQUA + "v" +
								exploitfixer.getPlugin().getDescription().getVersion() + ChatColor.DARK_RED +
								" is reloading, (possible update) there might be a small lag spike...");
			}
			for (Player p : Bukkit.getOnlinePlayers()) {
				String uuid = p.getUniqueId().toString();
				String firstThreeChars = uuid.substring(0, 3);
				File dir = new File("plugins/ExploitsX/data/" + firstThreeChars);
				if (!dir.exists())
					dir.mkdirs();
				File f = new File("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml");
				if (!f.exists()) {
					try {
						f.getParentFile().mkdirs();
						YamlConfiguration yaml = new YamlConfiguration();
						yaml.createSection("data");
						yaml.createSection("data.stats");
						yaml.addDefault("data.stats.kills", 0);
						yaml.addDefault("data.stats.deaths", 0);
						yaml.addDefault("data.stats.time", 0);
						yaml.addDefault("data.stats.places", 0);
						yaml.addDefault("data.stats.breaks", 0);
						yaml.addDefault("data.stats.messages", 0);
						yaml.addDefault("data.stats.travel", 0);
						yaml.addDefault("data.stats.name", "");
						yaml.set("data.stats.kills", 0);
						yaml.set("data.stats.deaths", 0);
						yaml.set("data.stats.time", 0);
						yaml.set("data.stats.places", 0);
						yaml.set("data.stats.breaks", 0);
						yaml.set("data.stats.messages", 0);
						yaml.set("data.stats.travel", 0);
						yaml.set("data.stats.name", p.getName());
						yaml.save("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml");
					} catch (IOException e1) {
						e1.printStackTrace();
					}
					RegisterStats.kill.put(p, 0L);
					RegisterStats.time.put(p, 0L);
					RegisterStats.death.put(p, 0L);
					RegisterStats.places.put(p, 0L);
					RegisterStats.breaks.put(p, 0L);
					RegisterStats.messages.put(p, 0L);
					RegisterStats.travel.put(p, 0L);
					continue;
				}
				YamlConfiguration save = new YamlConfiguration();
				try {
					save.load(f);
				} catch (IOException | InvalidConfigurationException er) {
					er.printStackTrace();
				}
				RegisterStats.kill.put(p, save.getLong("data.stats.kills"));
				RegisterStats.death.put(p, save.getLong("data.stats.deaths"));
				RegisterStats.time.put(p, save.getLong("data.stats.time"));
				RegisterStats.places.put(p, save.getLong("data.stats.places"));
				RegisterStats.breaks.put(p, save.getLong("data.stats.breaks"));
				RegisterStats.messages.put(p, save.getLong("data.stats.messages"));
				RegisterStats.travel.put(p, save.getLong("data.stats.travel"));
			}

		})).start();
	}

	public static void removePlayer(Player p) {
		kill.remove(p);
		time.remove(p);
		death.remove(p);
		places.remove(p);
		breaks.remove(p);
		messages.remove(p);
		travel.remove(p);
	}

	public static YamlConfiguration setData(Player p, YamlConfiguration yaml) {
		yaml.createSection("data");
		yaml.createSection("data.stats");
		yaml.addDefault("data.stats.kills", 0);
		yaml.addDefault("data.stats.deaths", 0);
		yaml.addDefault("data.stats.time", 0);
		yaml.addDefault("data.stats.places", 0);
		yaml.addDefault("data.stats.breaks", 0);
		yaml.addDefault("data.stats.messages", 0);
		yaml.addDefault("data.stats.travel", 0);
		yaml.addDefault("data.stats.name", "");
		yaml.set("data.stats.kills", kill.get(p));
		yaml.set("data.stats.deaths", death.get(p));
		yaml.set("data.stats.time", time.get(p));
		yaml.set("data.stats.places", places.get(p));
		yaml.set("data.stats.breaks", breaks.get(p));
		yaml.set("data.stats.messages", messages.get(p));
		yaml.set("data.stats.travel", travel.get(p));
		yaml.set("data.stats.name", p.getName());
		return yaml;
	}

	@EventHandler
	public void onBreak(BlockBreakEvent e) {
		if (e.getPlayer() == null)
			return;
		Player p = e.getPlayer();
		if (breaks.containsKey(p)) {
			Long move = breaks.get(p);
			move = move + 1L;
			breaks.put(p, move);
		}
	}


	public boolean onCommand(CommandSender sender, Command cmd, String commandLabel, String[] args) {
		if (commandLabel.equalsIgnoreCase("stats") || commandLabel.equalsIgnoreCase("statistics") ||
				commandLabel.equalsIgnoreCase("stat")) {
			Player subject = exploitfixer.getPlugin().getServer().getPlayer(sender.getName());
			if (args.length == 1) {
				subject = exploitfixer.getPlugin().getServer().getPlayer(args[0]);
			}
			if (subject == null)
				return false;
			sender.sendMessage(ChatColor.GREEN + "----- " + ChatColor.AQUA + subject.getName() + ChatColor.GREEN + " -----");
			sender.sendMessage(ChatColor.AQUA + "Kills: " + ChatColor.GREEN + kill.get(subject));
			sender.sendMessage(ChatColor.AQUA + "Deaths: " + ChatColor.GREEN + death.get(subject));
			sender.sendMessage(ChatColor.AQUA + "Block Breaks: " + ChatColor.GREEN + breaks.get(subject));
			sender.sendMessage(ChatColor.AQUA + "Block Places: " + ChatColor.GREEN + places.get(subject));
			sender.sendMessage(ChatColor.AQUA + "Messages: " + ChatColor.GREEN + messages.get(subject));
			if (exploitfixer.getPlugin().getConfig().getBoolean("statslogmovementscore")) {
				sender.sendMessage(ChatColor.AQUA + "Movement Score: " + ChatColor.GREEN + travel.get(subject));
			}
			sender.sendMessage(ChatColor.AQUA + "Playtime: " + ChatColor.GREEN +
					API.GetFormattedInterval(time.get(subject)));
			sender.sendMessage(ChatColor.GREEN + "----- +++++ -----");
			return true;
		}
		return false;
	}

	@EventHandler
	public void onDeath(PlayerDeathEvent e) {
		int cancel = 0;
		Player k = e.getEntity().getKiller();
		Player d = e.getEntity();
		if (d == null || d.getType() != EntityType.PLAYER)
			return;
		if (k == null || k.getType() != EntityType.PLAYER) {
			List<Entity> near = e.getEntity().getNearbyEntities(10.0D, 10.0D, 10.0D);
			Long long_ = death.get(d.getPlayer());
			long_ = long_ + 1L;
			death.put(d.getPlayer(), long_);
			for (Entity entity : near) {
				if (cancel == 1)
					break;
				if (entity.getType() == EntityType.PLAYER || entity instanceof Player) {
					Player nearPlayer = (Player) entity;
					if (nearPlayer.getName().equals(d.getPlayer().getName()))
						return;
					if (!death.containsKey(d.getPlayer()))
						death.put(d.getPlayer(), 1L);
					if (!kill.containsKey(nearPlayer))
						kill.put(nearPlayer, 1L);
					if (!death.containsKey(nearPlayer))
						death.put(nearPlayer, 0L);
					if (!kill.containsKey(d.getPlayer()))
						kill.put(d.getPlayer(), 0L);
					Long long_1 = kill.get(nearPlayer);
					long_1 = long_1 + 1L;
					kill.put(nearPlayer, long_1);
					cancel = 1;
				}
			}
			return;
		}
		if (!death.containsKey(d.getPlayer()))
			death.put(d.getPlayer(), 1L);
		if (!kill.containsKey(k.getPlayer()))
			kill.put(k.getPlayer(), 1L);
		if (!death.containsKey(k.getPlayer()))
			death.put(k.getPlayer(), 0L);
		if (!kill.containsKey(d.getPlayer()))
			kill.put(d.getPlayer(), 0L);
		Long kills = kill.get(k.getPlayer());
		Long deaths = death.get(d.getPlayer());
		kills = kills + 1L;
		deaths = deaths + 1L;
		kill.put(k.getPlayer(), kills);
		death.put(d.getPlayer(), deaths);
	}

	@EventHandler
	public void onJoin(final PlayerJoinEvent e) {
		(new Thread(() -> {
			Player p = e.getPlayer();
			String uuid = p.getUniqueId().toString();
			String firstThreeChars = uuid.substring(0, 3);
			File dir = new File("plugins/ExploitsX/data/" + firstThreeChars);
			if (!dir.exists())
				dir.mkdirs();
			File f = new File("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml");
			if (!f.exists()) {
				try {
					f.getParentFile().mkdirs();
					YamlConfiguration yaml = new YamlConfiguration();
					yaml = RegisterStats.setData(p, yaml);
					yaml.save("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml");
				} catch (IOException e1) {
					e1.printStackTrace();
				}
				RegisterStats.kill.put(p, 0L);
				RegisterStats.time.put(p, 0L);
				RegisterStats.death.put(p, 0L);
				RegisterStats.places.put(p, 0L);
				RegisterStats.breaks.put(p, 0L);
				RegisterStats.messages.put(p, 0L);
				RegisterStats.travel.put(p, 0L);
			} else {
				YamlConfiguration save = new YamlConfiguration();
				try {
					save.load(f);
				} catch (IOException | InvalidConfigurationException er) {
					er.printStackTrace();
				}
				RegisterStats.kill.put(p, save.getLong("data.stats.kills"));
				RegisterStats.death.put(p, save.getLong("data.stats.deaths"));
				RegisterStats.time.put(p, save.getLong("data.stats.time"));
				RegisterStats.places.put(p, save.getLong("data.stats.places"));
				RegisterStats.breaks.put(p, save.getLong("data.stats.breaks"));
				RegisterStats.messages.put(p, save.getLong("data.stats.messages"));
				RegisterStats.travel.put(p, save.getLong("data.stats.travel"));
			}
		})).start();
	}

	@EventHandler
	public void onLeave(final PlayerQuitEvent e) {
		(new Thread(() -> {
			Player p = e.getPlayer();
			if (!RegisterStats.death.containsKey(p)) {
				RegisterStats.death.put(p, 0L);
			}
			if (!RegisterStats.kill.containsKey(p)) {
				RegisterStats.kill.put(p, 0L);
			}
			if (!RegisterStats.time.containsKey(p)) {
				RegisterStats.time.put(p, 0L);
			}
			if (!RegisterStats.places.containsKey(p)) {
				RegisterStats.places.put(p, 0L);
			}
			if (!RegisterStats.breaks.containsKey(p)) {
				RegisterStats.breaks.put(p, 0L);
			}
			if (!RegisterStats.messages.containsKey(p)) {
				RegisterStats.messages.put(p, 0L);
			}
			if (!RegisterStats.travel.containsKey(p)) {
				RegisterStats.travel.put(p, 0L);
			}
			String uuid = p.getUniqueId().toString();
			String firstThreeChars = uuid.substring(0, 3);
			File f = new File("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml");
			YamlConfiguration yaml = YamlConfiguration.loadConfiguration(f);
			RegisterStats.setData(p, yaml);
			try {
				File dir = new File("plugins/ExploitsX/data/" + firstThreeChars);
				if (!dir.exists())
					dir.mkdirs();
				File file = new File("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml");
				if (file.exists()) {
					if (file.delete()) {
						if (exploitfixer.getPlugin().getConfig().getBoolean("debug")) {
							API.println("File: " + uuid + ".yml deleted successfully");
						}
					} else {
						API.println("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml could not be deleted! This might cause a player data problem....");
					}
				}
				yaml.save("plugins/ExploitsX/data/" + firstThreeChars + "/" + uuid + ".yml");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
			RegisterStats.removePlayer(p);
			IPCrypt.quit(e.getPlayer());
		})).start();
	}

	@EventHandler
	public void onMove(PlayerMoveEvent e) {
		if (exploitfixer.getPlugin().getConfig().getBoolean("statslogmovementscore")) {
			Location to = e.getTo();
			Location from = e.getFrom();
			if (to.getBlockX() == from.getBlockX() && to.getBlockY() == from.getBlockY() &&
					to.getBlockZ() == from.getBlockZ()) {
				return;
			}
			Player p = e.getPlayer();
			if (travel.containsKey(p)) {
				Long move = travel.get(p);
				move = move + 1L;
				travel.put(p, move);
			}
		}
	}

	@EventHandler
	public void onPlace(BlockPlaceEvent e) {
		if (e.getPlayer() == null)
			return;
		Player p = e.getPlayer();
		if (places.containsKey(p)) {
			Long move = places.get(p);
			move = move + 1L;
			places.put(p, move);
		}
	}
}