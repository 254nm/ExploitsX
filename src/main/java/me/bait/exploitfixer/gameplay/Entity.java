/*
 * .. _____________________ ..
 *  -- // WARNING \\ --
 *  -- THIS WORK IS UNDER EXCLUSIVE COPRIGHT FOR BAITCORP LABS. DISTRIBUTION, MODIFICATION, SELLING, OR SHARING WITHOUT EXPLICIT PERMISSION FROM BAITCORP LABS IS STRICTLY PROHIBITED.
 *  -- THIS PROGRAM IS LICENSED FOR MODIFICATION TO AND ONLY TO: "BAITCORP LABS" [FR], "CCHOST PARIS" [FR].
 *  --
 *  -- ExploitsX Sebastian Giheta 2019-2020
 * .. _____________________ ..
 *
 * .. _____________________ ..
 *  ___________              .__         .__  __         ____  ___              _________ .__            __   _________
 *  \_   _____/__  _________ |  |   ____ |__|/  |_  _____\   \/  /     .__      \_   ___ \|  |__ _____ _/  |_ \_   ___ \  ____
 *   |    __)_\  \/  /\____ \|  |  /  _ \|  \   __\/  ___/\     /    __|  |___  /    \  \/|  |  \\__  \\   __\/    \  \/ /  _ \
 *   |        \>    < |  |_> >  |_(  <_> )  ||  |  \___ \ /     \   /__    __/  \     \___|   Y  \/ __ \|  |  \     \___(  <_> )
 *  /_______  /__/\_ \|   __/|____/\____/|__||__| /____  >___/\  \     |__|      \______  /___|  (____  /__|   \______  /\____/
 *          \/      \/|__|                             \/      \_/                      \/     \/     \/              \/
 *
 *  ExploitsX by Sebastian Giheta, owner of 8b8t.xyz
 * .. _____________________ ..
 */

package me.bait.exploitfixer.gameplay;

import me.bait.exploitfixer.exploitfixer;
import me.bait.exploitfixer.util.API;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Dispenser;
import org.bukkit.entity.*;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockRedstoneEvent;
import org.bukkit.event.entity.CreatureSpawnEvent;
import org.bukkit.event.entity.EntitySpawnEvent;
import org.bukkit.event.player.PlayerDropItemEvent;
import org.bukkit.event.vehicle.VehicleCreateEvent;
import org.bukkit.inventory.ItemStack;

import java.util.Iterator;


public class Entity implements Listener {
	@EventHandler
	public void eggDispenser(BlockRedstoneEvent event) {
		if (event.getBlock().getType() == Material.DISPENSER || event.getBlock().getType() == Material.DROPPER) {
			Dispenser dispenser = (Dispenser) event.getBlock().getState();
			byte b;
			int i;
			ItemStack[] arrayOfItemStack;
			for (i = (arrayOfItemStack = dispenser.getInventory().getContents()).length, b = 0; b < i; ) {
				ItemStack itemStack = arrayOfItemStack[b];
				if (itemStack != null && (itemStack.getType() == Material.MONSTER_EGG || itemStack.getType() == Material.MONSTER_EGGS) && exploitfixer.getPlugin().getConfig().getBoolean("removeeggs")) {
					itemStack.setAmount(0);
					event.setNewCurrent(0);
					event.getBlock().setType(Material.AIR);
					if (exploitfixer.getPlugin().getConfig().getBoolean("debug")) {
						exploitfixer.getPlugin().getServer().getLogger().info("Blocked a spawn egg at " + event.getBlock().getLocation());
					}
				}
				b++;
			}
		}
	}

	@EventHandler
	public void onDrop(PlayerDropItemEvent event) {
		if (event.getItemDrop() != null) {
			int amount = 0;
			int max = exploitfixer.getPlugin().getConfig().getInt("Item-per-region.limit");
			Iterator<org.bukkit.entity.Entity> iterator = event.getItemDrop().getLocation().getWorld().getNearbyEntities(event.getItemDrop().getLocation(), 64.0D, 64.0D, 64.0D).iterator();
			while (iterator.hasNext()) {
				org.bukkit.entity.Entity ents = iterator.next();
				if (ents instanceof org.bukkit.entity.Item) {
					amount++;
				}
			}
			if (amount >= max) {
				event.setCancelled(true);
			}
		}
	}

	@EventHandler
	public void onMinecart(VehicleCreateEvent event) {
		int amount = 0;
		Chunk chunk = event.getVehicle().getChunk();
		Vehicle vehicle = event.getVehicle();
		Player player = API.getNearestPlayer(20.0, vehicle.getLocation());
		String formattedName = vehicle.getType().toString().toLowerCase().concat("s");
		int max = exploitfixer.getPlugin().getConfig().getInt("Vehicle-per-chunk.limit");
		for (org.bukkit.entity.Entity ents : vehicle.getLocation().getWorld().getNearbyEntities(vehicle.getLocation(), 64.0D, 256.0D, 64.0D)) {
			if (ents instanceof Vehicle) {
				amount++;
			}
		}
		if (amount >= max) {
			event.setCancelled(true);
			player.sendMessage(ChatColor.translateAlternateColorCodes('&', API.getPrefix() + "&6Please limit " + formattedName + " to &r&c" + max + "&r&6 per chunk"));
			API.alertMessage(API.getPrefix() + "&6Removed &r&3" + (chunk.getEntities()).length + " " + formattedName + "&r&6 from a lag source owned by&r&3 " + player.getName());
			Bukkit.getLogger().info(ChatColor.translateAlternateColorCodes('&', API.getPrefix() + "&6Removed &r&3" + (chunk.getEntities()).length + " " + formattedName + "&r&6 from a thick chunk owned by&r&3 " + player.getName()));
			byte b;
			int i;
			org.bukkit.entity.Entity[] arrayOfEntity;
			for (i = (arrayOfEntity = vehicle.getChunk().getEntities()).length, b = 0; b < i; ) {
				org.bukkit.entity.Entity ent = arrayOfEntity[b];
				if (ent instanceof Vehicle || ent instanceof ArmorStand)
					ent.remove();
				b++;
			}

		}
	}

	@EventHandler
	public void onSpawn(EntitySpawnEvent event) {
		if (event.getEntity() instanceof Item) {
			int amount = 0;
			int max = exploitfixer.getPlugin().getConfig().getInt("Item-per-region.limit");

			for (org.bukkit.entity.Entity ents : event.getEntity().getLocation().getWorld().getNearbyEntities(event.getLocation(), 32.0D, 96.0D, 32.0D)) {
				if (ents instanceof Item) {
					amount++;
				}
			}

			if (amount >= max) {
				event.setCancelled(true);
			}
		}
	}

	@EventHandler
	public void spawnEggs(CreatureSpawnEvent event) {
		if (event.getSpawnReason() == CreatureSpawnEvent.SpawnReason.SPAWNER_EGG) {
			if (exploitfixer.getPlugin().getConfig().getBoolean("denyeggs")) {
				event.setCancelled(true);
			}
		} else if (event.getSpawnReason() == CreatureSpawnEvent.SpawnReason.SPAWNER) {
			Creature entity = (Creature) event.getEntity();
			if (!(entity instanceof Monster)) {
				event.setCancelled(true);
			}
		} else if (event.getSpawnReason() == CreatureSpawnEvent.SpawnReason.DISPENSE_EGG &&
				exploitfixer.getPlugin().getConfig().getBoolean("denyeggs")) {
			event.getEntity().remove();
			event.setCancelled(true);
		}
	}
}