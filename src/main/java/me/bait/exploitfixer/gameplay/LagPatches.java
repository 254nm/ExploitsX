/*
 * .. _____________________ ..
 *  -- // WARNING \\ --
 *  -- THIS WORK IS UNDER EXCLUSIVE COPRIGHT FOR BAITCORP LABS. DISTRIBUTION, MODIFICATION, SELLING, OR SHARING WITHOUT EXPLICIT PERMISSION FROM BAITCORP LABS IS STRICTLY PROHIBITED.
 *  -- THIS PROGRAM IS LICENSED FOR MODIFICATION TO AND ONLY TO: "BAITCORP LABS" [FR], "CCHOST PARIS" [FR].
 *  --
 *  -- ExploitsX Sebastian Giheta 2019-2020
 * .. _____________________ ..
 *
 * .. _____________________ ..
 *  ___________              .__         .__  __         ____  ___              _________ .__            __   _________
 *  \_   _____/__  _________ |  |   ____ |__|/  |_  _____\   \/  /     .__      \_   ___ \|  |__ _____ _/  |_ \_   ___ \  ____
 *   |    __)_\  \/  /\____ \|  |  /  _ \|  \   __\/  ___/\     /    __|  |___  /    \  \/|  |  \\__  \\   __\/    \  \/ /  _ \
 *   |        \>    < |  |_> >  |_(  <_> )  ||  |  \___ \ /     \   /__    __/  \     \___|   Y  \/ __ \|  |  \     \___(  <_> )
 *  /_______  /__/\_ \|   __/|____/\____/|__||__| /____  >___/\  \     |__|      \______  /___|  (____  /__|   \______  /\____/
 *          \/      \/|__|                             \/      \_/                      \/     \/     \/              \/
 *
 *  ExploitsX by Sebastian Giheta, owner of 8b8t.xyz
 * .. _____________________ ..
 */

package me.bait.exploitfixer.gameplay;

import me.bait.exploitfixer.exploitfixer;
import me.bait.exploitfixer.util.API;
import me.bait.exploitfixer.util.TPS;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.entity.Wither;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.NotePlayEvent;
import org.bukkit.event.entity.EntitySpawnEvent;
import org.bukkit.event.entity.ExplosionPrimeEvent;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.scheduler.BukkitRunnable;

import java.util.HashMap;


public class LagPatches implements Listener {
	public HashMap<Player, Integer> vl = new HashMap<>();
	int count;

	@EventHandler(priority = EventPriority.HIGHEST)
	public void inElytra(final PlayerMoveEvent e) {
		double vdouble = exploitfixer.getPlugin().getConfig().getDouble("elytraint");
		if (e.getPlayer().isGliding() && TPS.getTPS() <= vdouble && e.getPlayer().getLocation().getY() < 5000.0D) {
			if (Math.abs(e.getFrom().getZ() - e.getTo().getZ()) + Math.abs(e.getFrom().getX() - e.getTo().getX()) + Math.abs(e.getFrom().getY() - e.getTo().getY()) > exploitfixer.getPlugin().getConfig().getDouble("vdouble")) {
				e.setCancelled(true);
				if (vl.containsKey(e.getPlayer()) && vl.get(e.getPlayer()) == 0) {
					vl.put(e.getPlayer(), 1);
					e.getPlayer().sendMessage(ChatColor.DARK_RED + "Elytras are disabled in low tps. Move to y level 5,000 or more once the TPS is back up in order to fly disregarding the TPS.");
					Bukkit.getScheduler().scheduleSyncDelayedTask(exploitfixer.getPlugin(), new BukkitRunnable() {
						public void run() {
							vl.put(e.getPlayer(), 0);
						}
					}, 60L);
				}
			}
		}
	}

	@EventHandler
	public void join(PlayerJoinEvent event) {
		vl.put(event.getPlayer(), 0);
	}

	@EventHandler
	public void note(NotePlayEvent event) {
		if (API.getTps() < exploitfixer.getPlugin().getConfig().getDouble("note-tps")) {
			event.setCancelled(true);
			if (API.getTps() < exploitfixer.getPlugin().getConfig().getDouble("note-remove") &&
					event.getBlock().getType() != Material.BEDROCK &&
					event.getBlock().getType() != Material.ENDER_PORTAL_FRAME) {
				event.getBlock().setType(Material.AIR);
			}
		}
	}

	@EventHandler
	public void onTNT(ExplosionPrimeEvent event) {
		if (TPS.getTPS() <= exploitfixer.getPlugin().getConfig().getDouble("tntint")) {
			event.setCancelled(true);
		}
	}

	@EventHandler
	public void onWitherSpawn(EntitySpawnEvent event) {
		if (event.getEntity() instanceof Wither) {
			if (TPS.getTPS() <= exploitfixer.getPlugin().getConfig().getDouble("witherspawn")) {
				event.setCancelled(true);
			}
			this.count = 0;
			for (Entity e : event.getEntity().getWorld().getNearbyEntities(event.getLocation(), 64.0D, 64.0D, 64.0D)) {
				if (e.getType() == EntityType.WITHER) {
					this.count++;
				}
			}
			if (this.count > exploitfixer.getPlugin().getConfig().getInt("maxwithers")) {
				event.setCancelled(true);
				Bukkit.getLogger().info("Cancelled a wither spawn from " + event.getEntity().getWorld().getNearbyPlayers(event.getEntity().getLocation(), 20.0D) + " due to high amounts at " + event.getLocation().getX() + ", " + event.getLocation().getY() + ", " + event.getLocation().getZ());
			}
		}
	}
}