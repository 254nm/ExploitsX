/*
 * .. _____________________ ..
 *  -- // WARNING \\ --
 *  -- THIS WORK IS UNDER EXCLUSIVE COPRIGHT FOR BAITCORP LABS. DISTRIBUTION, MODIFICATION, SELLING, OR SHARING WITHOUT EXPLICIT PERMISSION FROM BAITCORP LABS IS STRICTLY PROHIBITED.
 *  -- THIS PROGRAM IS LICENSED FOR MODIFICATION TO AND ONLY TO: "BAITCORP LABS" [FR], "CCHOST PARIS" [FR].
 *  --
 *  -- ExploitsX Sebastian Giheta 2019-2020
 * .. _____________________ ..
 *
 * .. _____________________ ..
 *  ___________              .__         .__  __         ____  ___              _________ .__            __   _________
 *  \_   _____/__  _________ |  |   ____ |__|/  |_  _____\   \/  /     .__      \_   ___ \|  |__ _____ _/  |_ \_   ___ \  ____
 *   |    __)_\  \/  /\____ \|  |  /  _ \|  \   __\/  ___/\     /    __|  |___  /    \  \/|  |  \\__  \\   __\/    \  \/ /  _ \
 *   |        \>    < |  |_> >  |_(  <_> )  ||  |  \___ \ /     \   /__    __/  \     \___|   Y  \/ __ \|  |  \     \___(  <_> )
 *  /_______  /__/\_ \|   __/|____/\____/|__||__| /____  >___/\  \     |__|      \______  /___|  (____  /__|   \______  /\____/
 *          \/      \/|__|                             \/      \_/                      \/     \/     \/              \/
 *
 *  ExploitsX by Sebastian Giheta, owner of 8b8t.xyz
 * .. _____________________ ..
 */

package me.bait.exploitfixer.gameplay;

import me.bait.exploitfixer.exploitfixer;
import me.bait.exploitfixer.util.API;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.block.ShulkerBox;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerKickEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;

import java.util.HashMap;


public class Join implements Listener {
	public static HashMap<Player, Integer> ef = new HashMap<>();
	public static HashMap<Player, Integer> send = new HashMap<>();
	int bookamt;

	public void clearbooks(Player player) {
		if (ef.containsKey(player) && ef.get(player) > 4) {
			byte b;
			int i;
			ItemStack[] arrayOfItemStack;
			for (i = (arrayOfItemStack = player.getInventory().getContents()).length, b = 0; b < i; ) {
				ItemStack item = arrayOfItemStack[b];
				if (item != null && item.getType() != null) {
					if (item.getType() == Material.WRITTEN_BOOK || item.getType() == Material.BOOK_AND_QUILL) {
						item.setAmount(0);
					}
					if (API.isShulkerBox(item.getType())) {
						BlockStateMeta meta = (BlockStateMeta) item.getItemMeta();
						if (meta == null) return;
						ShulkerBox box = (ShulkerBox) meta.getBlockState();
						if (box == null) return;
						this.bookamt = 0;
						byte b1;
						int j;
						ItemStack[] arrayOfItemStack1;
						for (j = (arrayOfItemStack1 = box.getInventory().getContents()).length, b1 = 0; b1 < j; ) {
							ItemStack itemStack = arrayOfItemStack1[b1];
							if (itemStack != null && itemStack.getType() != null && (itemStack.getType() == Material.WRITTEN_BOOK || itemStack.getType() == Material.BOOK_AND_QUILL)) {
								item.setAmount(0);
								b1++;
							}
						}
					}
				}
				b++;
			}
			send.put(player, 1);
		}
	}


	@EventHandler
	public void onJoin(PlayerJoinEvent e) {
		if (!exploitfixer.getPlugin().getConfig().getBoolean("enableantibookban"))
			return;
		bookamt = 0;
		final Player player = e.getPlayer();
		byte b;
		int i;
		ItemStack[] arrayOfItemStack;
		for (i = (arrayOfItemStack = player.getInventory().getContents()).length, b = 0; b < i; ) {
			ItemStack item = arrayOfItemStack[b];
			if (item != null && item.getType() != null) {
				if (item.getType().toString().equals("WRITTEN_BOOK") || item.getType().toString().equals("BOOK_AND_QUILL")) {
					bookamt++;
				}
				if (bookamt > 8) {
					if (ef.containsKey(player)) {
						ef.put(player, ef.get(player) + 1);
					} else {
						ef.put(player, 1);
					}
				}
				if (API.isShulkerBox(item.getType())) {
					BlockStateMeta meta = (BlockStateMeta) item.getItemMeta();
					if (meta == null) return;
					ShulkerBox box = (ShulkerBox) meta.getBlockState();
					if (box == null) return;
					byte b1;
					int j;
					ItemStack[] arrayOfItemStack1;
					for (j = (arrayOfItemStack1 = box.getInventory().getContents()).length, b1 = 0; b1 < j; ) {
						ItemStack itemStack = arrayOfItemStack1[b1];
						if (itemStack != null && (itemStack.getType() == Material.WRITTEN_BOOK || itemStack.getType() == Material.BOOK_AND_QUILL)) {
							bookamt++;
							if (bookamt > 8) {
								if (ef.containsKey(player)) {
									ef.put(player, ef.get(player) + 1);
								} else {
									ef.put(player, 1);
								}
							}
						}
						b1++;
					}
				}
			}
			b++;
		}

		if (ef.containsKey(player) && ef.get(player) > 4) {
			player.sendMessage(ChatColor.DARK_RED + "ExploitsX > DO NOT LEAVE WITHIN 3 SECONDS. If you do, books in your inventory will be cleared. Please limit the books in your inventory at once.");
			Bukkit.getScheduler().scheduleSyncDelayedTask(exploitfixer.getPlugin(), () -> ef.remove(player), 60L);
		}

		if (send.containsKey(player) && send.get(player) > 0) {
			player.sendMessage(ChatColor.DARK_RED + "ExploitsX > You left the server too quickly after joining, therefore your books were cleared in suspicion of a book ban.");
			send.remove(player);
		}
	}


	@EventHandler
	public void onLeave(PlayerQuitEvent e) {
		if (!exploitfixer.getPlugin().getConfig().getBoolean("enableantibookban"))
			return;
		Player player = e.getPlayer();
		clearbooks(player);
	}

	@EventHandler
	public void onLeave2(PlayerKickEvent e) {
		if (!exploitfixer.getPlugin().getConfig().getBoolean("enableantibookban"))
			return;
		Player player = e.getPlayer();
		clearbooks(player);
	}
}
